'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.printTypeMap = exports.createOperationMap = exports.extractResolversFromSchema = exports.extractAstNodesFromSchema = exports.augmentResolvers = exports.augmentTypeDefs = exports.makeAugmentedSchema = undefined;

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _graphqlTools = require('graphql-tools');

var _index = require('./index');

var _graphql = require('graphql');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var makeAugmentedSchema = exports.makeAugmentedSchema = function makeAugmentedSchema(schema, augmentedTypeMap, queryMap, mutationMap) {
  return (0, _graphqlTools.makeExecutableSchema)({
    typeDefs: printTypeMap(augmentedTypeMap),
    resolvers: augmentResolvers(schema, augmentedTypeMap, queryMap, mutationMap),
    resolverValidationOptions: {
      requireResolversForResolveType: false
    }
  });
};

var augmentTypeDefs = exports.augmentTypeDefs = function augmentTypeDefs(typeMap) {
  var astNode = {};
  var types = (0, _keys2.default)(typeMap);
  typeMap = initializeOperationTypes(types, typeMap);
  var queryMap = createOperationMap(typeMap.Query);
  var mutationMap = createOperationMap(typeMap.Mutation);
  types.forEach(function (t) {
    astNode = typeMap[t];
    if (isTypeForAugmentation(astNode)) {
      astNode = augmentType(astNode);
      // typeMap = possiblyAddQuery(astNode, typeMap, queryMap);
      typeMap = possiblyAddMutations(astNode, typeMap, mutationMap);
      // typeMap = possiblyAddOrderingEnum(astNode, typeMap);
      typeMap[t] = astNode;
    }
  });
  return typeMap;
};

var augmentResolvers = exports.augmentResolvers = function augmentResolvers(schema, augmentedTypeMap, queryMap, mutationMap) {
  // For now, only adds resolvers for auto-generated mutations
  var resolvers = extractResolversFromSchema(schema);
  resolvers = augmentMutationResolvers(resolvers, augmentedTypeMap, mutationMap);
  return resolvers;
};

var extractAstNodesFromSchema = exports.extractAstNodesFromSchema = function extractAstNodesFromSchema(schema) {
  var typeMap = schema.getTypeMap();
  var astNode = {};
  return (0, _keys2.default)(typeMap).reduce(function (acc, t) {
    astNode = typeMap[t].astNode;
    if (astNode !== undefined) {
      acc[astNode.name.value] = astNode;
    }
    return acc;
  }, {});
};

var extractResolversFromSchema = exports.extractResolversFromSchema = function extractResolversFromSchema(schema) {
  var queryResolvers = extractResolvers(schema.getQueryType());
  var mutationResolvers = extractResolvers(schema.getMutationType());
  var extracted = {};
  if (queryResolvers) extracted.Query = queryResolvers;
  if (mutationResolvers) extracted.Mutation = mutationResolvers;
  return extracted;
};

var createOperationMap = exports.createOperationMap = function createOperationMap(type) {
  var fields = type ? type.fields : [];
  return fields.reduce(function (acc, t) {
    acc[t.name.value] = t;
    return acc;
  }, {});
};

var printTypeMap = exports.printTypeMap = function printTypeMap(typeMap) {
  var printed = (0, _graphql.print)({
    "kind": "Document",
    "definitions": (0, _values2.default)(typeMap)
  });
  return printed;
};

var possiblyAddQuery = function possiblyAddQuery(astNode, typeMap, queryMap) {
  var name = astNode.name.value;
  if (queryMap[name] === undefined) {
    typeMap.Query.fields.push({
      "kind": "FieldDefinition",
      "name": {
        "kind": "Name",
        "value": name
      },
      "arguments": createQueryArguments(astNode, typeMap),
      "type": {
        "kind": "ListType",
        "type": {
          "kind": "NamedType",
          "name": {
            "kind": "Name",
            "value": name
          }
        }
      },
      "directives": []
    });
  }
  return typeMap;
};

var possiblyAddMutations = function possiblyAddMutations(astNode, typeMap, mutationMap) {
  typeMap = possiblyAddTypeMutation('Create', astNode, typeMap, mutationMap);
  typeMap = possiblyAddTypeMutation('Update', astNode, typeMap, mutationMap);
  typeMap = possiblyAddTypeMutation('Delete', astNode, typeMap, mutationMap);
  typeMap = possiblyAddRelationMutations(astNode, typeMap, mutationMap);
  return typeMap;
};

var possiblyAddOrderingEnum = function possiblyAddOrderingEnum(astNode, typeMap) {
  var name = '_' + astNode.name.value + 'Ordering';
  var values = createOrderingFields(astNode.fields, typeMap);
  // Add ordering enum if it does not exist already and if
  // there is at least one basic scalar field on this type
  if (typeMap[name] === undefined && values.length > 0) {
    typeMap[name] = {
      kind: "EnumTypeDefinition",
      name: {
        kind: "Name",
        value: name
      },
      directives: [],
      values: values
    };
  }
  return typeMap;
};

var initializeOperationTypes = function initializeOperationTypes(types, typeMap) {
  if (types.length > 0) {
    typeMap = possiblyAddObjectType(typeMap, "Query");
    typeMap = possiblyAddObjectType(typeMap, "Mutation");
  }
  return typeMap;
};

var augmentType = function augmentType(astNode) {
  astNode.fields = addOrReplaceNodeIdField(astNode, "ID");
  return astNode;
};

var possiblyAddTypeMutation = function possiblyAddTypeMutation(namePrefix, astNode, typeMap, mutationMap) {
  var typeName = astNode.name.value;
  var mutationName = namePrefix + typeName;
  // Only generate if the mutation named mutationName does not already exist
  if (mutationMap[mutationName] === undefined) {
    typeMap.Mutation.fields.push({
      "kind": "FieldDefinition",
      "name": {
        "kind": "Name",
        "value": mutationName
      },
      "arguments": buildAllFieldArguments(namePrefix, astNode, typeMap),
      "type": {
        "kind": "NamedType",
        "name": {
          "kind": "Name",
          "value": typeName
        }
      },
      "directives": []
    });
  }
  return typeMap;
};

var buildAllFieldArguments = function buildAllFieldArguments(namePrefix, astNode, typeMap) {
  var fields = [];
  var type = {};
  var fieldName = "";
  switch (namePrefix) {
    case 'Create':
      {
        fields = astNode.fields.reduce(function (acc, t) {
          type = getNamedType(t);
          fieldName = t.name.value;
          if (isValidOptionalMutationArgument(fieldName, type, typeMap)) {
            acc.push({
              "kind": "InputValueDefinition",
              "name": {
                "kind": "Name",
                "value": fieldName
              },
              "type": type,
              "directives": []
            });
          }
          return acc;
        }, []);
        break;
      }
    case 'Update':
      {
        fields = astNode.fields.reduce(function (acc, t) {
          type = getNamedType(t);
          fieldName = t.name.value;
          if (isValidOptionalMutationArgument(fieldName, type, typeMap)) {
            acc.push({
              "kind": "InputValueDefinition",
              "name": {
                "kind": "Name",
                "value": fieldName
              },
              "type": type,
              "directives": []
            });
          }
          return acc;
        }, []);
        break;
      }
    case 'Delete':
      {
        var primaryKey = getPrimaryKey(astNode);
        fields.push({
          "kind": "InputValueDefinition",
          "name": {
            "kind": "Name",
            "value": primaryKey.name.value
          },
          "type": primaryKey.type,
          "directives": []
        });
        break;
      }
  }
  return fields;
};

var isValidOptionalMutationArgument = function isValidOptionalMutationArgument(fieldName, type, typeMap) {
  var valueTypeName = type.name.value;
  var valueType = typeMap[valueTypeName];
  return fieldName !== "_id" && (isBasicScalar(valueTypeName) || valueType && valueType.kind === "EnumTypeDefinition");
};

var firstNonNullAndIdField = function firstNonNullAndIdField(fields) {
  var valueTypeName = "";
  return fields.find(function (e) {
    valueTypeName = getNamedType(e).name.value;
    return e.name.value !== '_id' && e.type.kind === 'NonNullType' && valueTypeName === 'ID';
  });
};

var firstIdField = function firstIdField(fields) {
  var valueTypeName = "";
  return fields.find(function (e) {
    valueTypeName = getNamedType(e).name.value;
    return e.name.value !== '_id' && valueTypeName === 'ID';
  });
};

var firstNonNullField = function firstNonNullField(fields) {
  var valueTypeName = "";
  return fields.find(function (e) {
    valueTypeName = getNamedType(e).name.value;
    return valueTypeName === 'NonNullType';
  });
};

var firstField = function firstField(fields) {
  return fields.find(function (e) {
    return e.name.value !== '_id';
  });
};

var getPrimaryKey = function getPrimaryKey(astNode) {
  var fields = astNode.fields;
  var pk = firstNonNullAndIdField(fields);
  if (!pk) {
    pk = firstIdField(fields);
  }
  if (!pk) {
    pk = firstNonNullField(fields);
  }
  if (!pk) {
    pk = firstField(fields);
  }
  return pk;
};

var possiblyAddRelationMutations = function possiblyAddRelationMutations(astNode, typeMap, mutationMap) {
  var typeName = astNode.name.value;
  var relationTypeName = "";
  var relationDirective = {};
  var relationName = "";
  var direction = "";
  astNode.fields.forEach(function (e) {
    relationDirective = getDirective(e, "relation");
    if (relationDirective) {
      relationName = getRelationName(relationDirective);
      direction = getRelationDirection(relationDirective);
      relationTypeName = getNamedType(e).name.value;
      possiblyAddRelationMutationField('Add' + typeName + relationTypeName, astNode, typeName, relationTypeName, direction, relationName, typeMap, mutationMap);
      possiblyAddRelationMutationField('Remove' + typeName + relationTypeName, astNode, typeName, relationTypeName, direction, relationName, typeMap, mutationMap);
    }
  });
  return typeMap;
};

var getDirective = function getDirective(field, directive) {
  return field.directives.find(function (e) {
    return e.name.value === directive;
  });
};

var buildRelationMutationArguments = function buildRelationMutationArguments(astNode, relationTypeName, typeMap) {
  var relationAstNode = typeMap[relationTypeName];
  if (relationAstNode) {
    var primaryKey = getPrimaryKey(astNode);
    var relationPrimaryKey = getPrimaryKey(relationAstNode);
    var relationType = getNamedType(relationPrimaryKey);
    return [{
      "kind": "InputValueDefinition",
      "name": {
        "kind": "Name",
        "value": astNode.name.value.toLowerCase() + primaryKey.name.value
      },
      "type": {
        "kind": "NonNullType",
        "type": getNamedType(primaryKey)
      },
      "directives": []
    }, {
      "kind": "InputValueDefinition",
      "name": {
        "kind": "Name",
        "value": relationAstNode.name.value.toLowerCase() + relationPrimaryKey.name.value
      },
      "type": {
        "kind": "NonNullType",
        "type": relationType
      },
      "directives": []
    }];
  }
};

var possiblyAddRelationMutationField = function possiblyAddRelationMutationField(mutationName, astNode, typeName, relationTypeName, direction, name, typeMap, mutationMap) {
  // Only generate if the mutation named mutationName does not already exist,
  // and only generate for one direction, OUT, in order to prevent duplication
  if (mutationMap[mutationName] === undefined && (direction === "OUT" || direction === "out")) {
    typeMap.Mutation.fields.push({
      "kind": "FieldDefinition",
      "name": {
        "kind": "Name",
        "value": mutationName
      },
      "arguments": buildRelationMutationArguments(astNode, relationTypeName, typeMap),
      "type": {
        "kind": "NamedType",
        "name": {
          "kind": "Name",
          "value": typeName
        }
      },
      "directives": [{
        "kind": "Directive",
        "name": {
          "kind": "Name",
          "value": "MutationMeta"
        },
        "arguments": [{
          "kind": "Argument",
          "name": {
            "kind": "Name",
            "value": "relationship"
          },
          "value": {
            "kind": "StringValue",
            "value": name
          }
        }, {
          "kind": "Argument",
          "name": {
            "kind": "Name",
            "value": "from"
          },
          "value": {
            "kind": "StringValue",
            "value": typeName
          }
        }, {
          "kind": "Argument",
          "name": {
            "kind": "Name",
            "value": "to"
          },
          "value": {
            "kind": "StringValue",
            "value": relationTypeName
          }
        }]
      }]
    });
  }
  return typeMap;
};

var addOrReplaceNodeIdField = function addOrReplaceNodeIdField(astNode, valueType) {
  var fields = astNode ? astNode.fields : [];
  var index = fields.findIndex(function (e) {
    return e.name.value === '_id';
  });
  var definition = {
    "kind": "FieldDefinition",
    "name": {
      "kind": "Name",
      "value": "_id"
    },
    "arguments": [],
    "type": {
      "kind": "NamedType",
      "name": {
        "kind": "Name",
        "value": valueType
      }
    },
    "directives": []
  };
  // If it has already been provided, replace it to force valueType,
  // else add it as the last field
  index >= 0 ? fields.splice(index, 1, definition) : fields.push(definition);
  return fields;
};

var possiblyAddMutationResolver = function possiblyAddMutationResolver(name, resolvers, mutationMap) {
  if (resolvers.Mutation === undefined) resolvers.Mutation = {};
  // Only generate resolver for a generated mutation type
  // So, don't generate if there is an entry in mutationMap
  if (mutationMap[name] !== undefined) return resolvers;
  // Even if the mutation type is generated, only generate
  // a resolver if the user has not written one
  if (resolvers.Mutation[name] === undefined) {
    resolvers.Mutation[name] = _index.neo4jgraphql;
  }
  return resolvers;
};

var possiblyAddRelationMutationResolvers = function possiblyAddRelationMutationResolvers(astNode, typeName, resolvers, mutationMap) {
  var relationDirective = {};
  var relationTypeName = "";
  var relationName = "";
  var direction = "";
  astNode.fields.forEach(function (e) {
    relationDirective = getDirective(e, "relation");
    if (relationDirective) {
      relationName = getRelationName(relationDirective);
      direction = getRelationDirection(relationDirective);
      if (direction === "OUT" || direction === "out") {
        relationTypeName = getNamedType(e).name.value;
        resolvers = possiblyAddMutationResolver('Add' + typeName + relationTypeName, resolvers, mutationMap);
        resolvers = possiblyAddMutationResolver('Remove' + typeName + relationTypeName, resolvers, mutationMap);
      }
    }
  });
  return resolvers;
};

var augmentMutationResolvers = function augmentMutationResolvers(resolvers, typeMap, mutationMap) {
  var astNode = {};
  var typeName = "";
  (0, _keys2.default)(typeMap).forEach(function (e) {
    astNode = typeMap[e];
    typeName = astNode.name.value;
    // Should be greatly simplified if we generate resolvers for any
    // mutation for which one is not provided. For now, this matches the
    // typeDefs augmentation logic to only generate resolvers for the same
    // mutation types that were generated
    if (isTypeForAugmentation(astNode)) {
      resolvers = possiblyAddMutationResolver('Create' + typeName, resolvers, mutationMap);
      resolvers = possiblyAddMutationResolver('Update' + typeName, resolvers, mutationMap);
      resolvers = possiblyAddMutationResolver('Delete' + typeName, resolvers, mutationMap);
      resolvers = possiblyAddRelationMutationResolvers(astNode, typeName, resolvers, mutationMap);
    }
  });
  return resolvers;
};

var getRelationName = function getRelationName(relationDirective) {
  var name = {};
  try {
    name = relationDirective.arguments.filter(function (a) {
      return a.name.value === 'name';
    })[0];
  } catch (e) {
    // FIXME: should we ignore this error to define default behavior?
    throw new Error('No name argument specified on @relation directive');
  }
  return name.value.value;
};

var getRelationDirection = function getRelationDirection(relationDirective) {
  var direction = {};
  try {
    direction = relationDirective.arguments.filter(function (a) {
      return a.name.value === 'direction';
    })[0];
  } catch (e) {
    // FIXME: should we ignore this error to define default behavior?
    throw new Error('No direction argument specified on @relation directive');
  }
  return direction.value.value;
};

var possiblyAddObjectType = function possiblyAddObjectType(typeMap, name) {
  if (typeMap[name] === undefined) {
    typeMap[name] = {
      kind: 'ObjectTypeDefinition',
      name: {
        kind: 'Name',
        value: name
      },
      interfaces: [],
      directives: [],
      fields: []
    };
  }
  return typeMap;
};

var isBasicScalar = function isBasicScalar(name) {
  return name === "ID" || name === "String" || name === "Float" || name === "Int" || name === "Boolean";
};

var isQueryArgumentFieldType = function isQueryArgumentFieldType(type, valueType) {
  return isBasicScalar(type.name.value) || valueType && valueType.kind === "EnumTypeDefinition";
};

var createQueryArguments = function createQueryArguments(astNode, typeMap) {
  var type = {};
  var valueTypeName = "";
  astNode.fields = addOrReplaceNodeIdField(astNode, "Int");
  var fieldArguments = astNode.fields.reduce(function (acc, t) {
    type = getNamedType(t);
    valueTypeName = type.name.value;
    if (isQueryArgumentFieldType(type, typeMap[valueTypeName])) {
      acc.push({
        "kind": "InputValueDefinition",
        "name": {
          "kind": "Name",
          "value": t.name.value
        },
        "type": type,
        "directives": []
      });
    }
    return acc;
  }, []);
  return [].concat((0, _toConsumableArray3.default)(fieldArguments), [{
    "kind": "InputValueDefinition",
    "name": {
      "kind": "Name",
      "value": "first"
    },
    "type": {
      "kind": "NamedType",
      "name": {
        "kind": "Name",
        "value": "Int"
      }
    },
    "directives": []
  }, {
    "kind": "InputValueDefinition",
    "name": {
      "kind": "Name",
      "value": "offset"
    },
    "type": {
      "kind": "NamedType",
      "name": {
        "kind": "Name",
        "value": "Int"
      }
    },
    "directives": []
  }, {
    "kind": "InputValueDefinition",
    "name": {
      "kind": "Name",
      "value": "orderBy"
    },
    "type": {
      "kind": "NamedType",
      "name": {
        "kind": "Name",
        "value": '_' + astNode.name.value + 'Ordering'
      }
    },
    "directives": []
  }]);
};

var isTypeForAugmentation = function isTypeForAugmentation(astNode) {
  // TODO: check for @ignore and @model directives
  return astNode.kind === "ObjectTypeDefinition" && astNode.name.value !== "Query" && astNode.name.value !== "Mutation";
};

var getNamedType = function getNamedType(type) {
  if (type.kind !== "NamedType") {
    return getNamedType(type.type);
  }
  return type;
};

var createOrderingFields = function createOrderingFields(fields, typeMap) {
  var type = {};
  return fields.reduce(function (acc, t) {
    type = getNamedType(t);
    if (isBasicScalar(type.name.value)) {
      acc.push({
        kind: 'EnumValueDefinition',
        name: {
          kind: "Name",
          value: t.name.value + '_asc'
        },
        directives: []
      });
      acc.push({
        kind: 'EnumValueDefinition',
        name: {
          kind: "Name",
          value: t.name.value + '_desc'
        },
        directives: []
      });
    }
    return acc;
  }, []);
};

var extractResolvers = function extractResolvers(operationType) {
  var operationTypeFields = operationType ? operationType.getFields() : {};
  var operations = (0, _keys2.default)(operationTypeFields);
  var resolver = {};
  return operations.length > 0 ? operations.reduce(function (acc, t) {
    resolver = operationTypeFields[t].resolve;
    if (resolver !== undefined) acc[t] = resolver;
    return acc;
  }, {}) : undefined;
};