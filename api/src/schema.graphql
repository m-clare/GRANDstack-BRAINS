type State {
  id: ID!
  code: String
  name: String
  abbreviation: String
  latitude_decimal: Float
  longitude_decimal: Float

  bridges: [Bridge] @cypher(statement: "MATCH (this)<-[:OF_STATE]-(:County)<-[:OF_COUNTY]-(:Place)<-[:OF_PLACE]-(bridge:Bridge) RETURN bridge")

  numCounties: Int @cypher(statement: "MATCH (this)<-[:OF_STATE]-(c:County) RETURN count(DISTINCT c)")
  numPlaces: Int @cypher(statement: "MATCH (this)<-[:OF_STATE]-(:County)<-[:OF_COUNTY]-(p:Place) RETURN count(DISTINCT p)")
  numBridges: Int @cypher(statement: "MATCH (this)<-[:OF_STATE]-(:County)<-[:OF_COUNTY]-(:Place)<-[:OF_PLACE]-(b:Bridge) RETURN count(DISTINCT b)")

  chartBarBridgeByBuildYear: [BarChartPairs] @cypher(statement: """
    MATCH (this)<-[:OF_STATE]-(:County)<-[:OF_COUNTY]-(:Place)<-[:OF_PLACE]-(bridge:Bridge) 
    WITH bridge.yearbuilt AS year, count(bridge) AS count
    RETURN {year: year, count: count} AS datapoint
    ORDER BY year ASC
    """
  )

  # chartHeatMapStateOwnerCount(owners: [String]): Int @cypher(statement: """
  #   MATCH (this)<-[*]-(bridge:Bridge)-[:OWNED_BY]->(owner:Owner)
  #   WHERE owner.description in $owners
  #   RETURN count(bridge)
  #   """
  # )

  # chartHeatMapStateOwnerCount(owner: String): Int @cypher(statement: """
  # chartHeatMapStateOwnerCount: Int @cypher(statement: """
  #   MATCH (this)<-[*]-(bridge:Bridge)-[:OWNED_BY]->(owner:Owner)
  #   RETURN count(bridge)
  #   """
  # )

  # chartHeatMapStateOwnerCount(owners: [String]): [String], [Int] @cypher(statement: """
  #   MATCH (this)<-[*]-(bridge:Bridge)-[:OWNED_BY]->(owner:Owner)
  #   WHERE owner.description in $owners
  #   RETURN owner.description, count(bridge)
  #   """
  # )

  # chartHeatMapStateOwners(owners: [String]): String @cypher(statement: """
  #   MATCH (this)<-[*]-(:Bridge)-[OWNED_BY]->(owner:Owner)
  #   WHERE owner.description in $owners
  #   RETURN owner.description
  #   """
  # )

  chartHeatMapStateOwners(owners: [String]): [Pairs] @cypher(statement: """
    MATCH (this)
    UNWIND $owners AS owner
    WITH [ (this)<-[*]-(b:Bridge)-[:OWNED_BY]->(o:Owner) WHERE o.description = owner | b ] AS bridges, owner
    WITH owner AS ownerDescription, size(bridges) AS bridgeCount
    RETURN {ownerDescription: ownerDescription, bridgeCount: bridgeCount} AS datapoint
    """
  )

  county: [County] @relation(name: "OF_STATE", direction: "IN")
}

type County {
  id: ID!
  name: String

  state: State @relation(name: "OF_STATE", direction: "OUT")
  place: [Place] @relation(name: "OF_COUNTY", direction: "IN")
}

type Place {
  id: ID!
  name: String

  county: County @relation(name: "OF_COUNTY", direction: "OUT")
  bridge: [Bridge] @relation(name: "OF_PLACE", direction: "IN")
}

type Bridge {
  id: ID!
  name: String
  latitude_decimal: Float
  longitude_decimal: Float
  yearbuilt: Int

  place: Place @relation(name: "OF_PLACE", direction: "OUT")
  buildYear: BuildYear @relation(name: "BUILT_IN", direction: "OUT")
  maintenanceResp: MaintenanceResp @relation(name: "MAINTAINED_BY", direction: "OUT")
  owner: Owner @relation(name: "OWNED_BY", direction: "OUT")

}

type BuildYear {
  id: ID!
  year: Int

  bridge: [Bridge] @relation(name: "BUILT_IN", direction: "IN")
}

type MaintenanceResp {
  id: ID!
  description: String

  bridge: [Bridge] @relation(name: "MAINTAINED_BY", direction: "IN")
}

type Owner {
  id: ID!
  description: String

  bridge: [Bridge] @relation(name: "OWNED_BY", direction: "IN")
}

type HeatMapDataPoint {
  stateName: String
  ownerDescription: String
  bridgeCount: Int
}

type HeatMapDataPoint_1 {
  stateName: String
  pairs: [Pairs]
}

type Pairs {
  ownerDescription: String
  bridgeCount: Int
}

type BarChartPairs 
{
  year: Int
  count: Int
}

type NodeCount {
  label: String
  count: Int
}

# type NodeSummary {

# }

type RelationshipCount {
  type: String
  count: Int
}

type Query {
    
  bridge(state: String, owner: String): [Bridge] @cypher(statement: """
    MATCH (b:Bridge)-[*]->(state:State)
    MATCH (b)-->(o:Owner)
    WHERE state.name = $state
    AND by.year = $year
    RETURN b
  """
    )

  nodeSummaryCount: [NodeCount] @cypher(statement: """
    MATCH (n)
    WITH DISTINCT labels(n) AS labels, count(n) AS labelCount
    UNWIND labels AS label
    RETURN { label: label, count: sum(labelCount) } AS nodeCount
    ORDER BY nodeCount.count DESC, nodeCount.label ASC
    """
  )

  NodeCount(label: String, count: Int): [NodeCount]

  relationshipSummaryCount: [RelationshipCount] @cypher(statement: """
    MATCH ()-[r]->()
    WITH DISTINCT type(r) AS rel, count(r) AS relCount
    RETURN {type: rel, count: relCount } AS relationshipCount
    ORDER BY relationshipCount.count DESC, relationshipCount.type ASC
    """
  )

  RelationshipCount(type: String, count: Int): [RelationshipCount]

  heatmapData(states: [String], owners: [String]): [HeatMapDataPoint] @cypher(statement: """
    MATCH (s:State)<-[*]-(b:Bridge)-[:OWNED_BY]->(o:Owner)
    WHERE s.name IN $states
    AND o.description IN $owners
    WITH s.name AS stateName, o.description AS ownerDescription, count(b) AS bridgeCount
    RETURN {stateName: stateName, ownerDescription: ownerDescription, bridgeCount: bridgeCount} AS datapoint
    """
  )

  heatmapData_1(states: [String], owners: [String]): [HeatMapDataPoint_1] @cypher(statement: """
    MATCH (s:State)<-[*]-(b:Bridge)-[:OWNED_BY]->(o:Owner)
    WHERE s.name IN $states
    AND o.description IN $owners
    WITH s.name AS stateName, o.description AS ownerDescription, count(b) AS bridgeCount
    RETURN {stateName: stateName, pairs: collect({ownerDescription: ownerDescription, bridgeCount: bridgeCount})} AS datapoint
    """
  )

  Pairs(ownerDescription: String, bridgeCount: Int): [Pairs]

  BarChartPairs(year: Int, count: Int): [BarChartPairs]

  # chartHeatMapStateOwner2(state: [String], owner: [String]): Int @cypher(statement: """
  #   MATCH (state:State)
  #   WHERE state.name in $state
  #   WITH state
  #   MATCH (state)<-[*]-(bridge:Bridge)-[:OWNED_BY]->(owner:Owner)
  #   WHERE owner.description in $owner
  #   //RETURN state.name, owner.description, count(bridge)
  #   RETURN count(bridge)
  #   //RETURN state
  #   """
  # )

  # usersBySubstring(substring: String, first: Int = 10, offset: Int = 0): [User] @cypher(statement: "MATCH (u:User) WHERE u.name CONTAINS $substring RETURN u")
 
}
